***************************************************************
** 各種レジスタ定義
***************************************************************
***************
** レジスタ群の先頭
***************
.equ REGBASE, 0xFFF000 | DMAP を使用．
.equ IOBASE, 0x00d00000
***************
** 割り込み関係のレジスタ
***************
.equ IVR, REGBASE+0x300 | 割り込みベクタレジスタ
.equ IMR, REGBASE+0x304 | 割り込みマスクレジスタ
.equ ISR, REGBASE+0x30c | 割り込みステータスレジスタ
.equ IPR, REGBASE+0x310 | 割り込みペンディングレジスタ
***************
** タイマ関係のレジスタ
***************
.equ TCTL1, REGBASE+0x600 | タイマ１コントロールレジスタ
.equ TPRER1, REGBASE+0x602 | タイマ１プリスケーラレジスタ
.equ TCMP1, REGBASE+0x604 | タイマ１コンペアレジスタ
.equ TCN1, REGBASE+0x608 | タイマ１カウンタレジスタ
.equ TSTAT1, REGBASE+0x60a | タイマ１ステータスレジスタ
***************
** UART1（送受信）関係のレジスタ
***************
.equ USTCNT1, REGBASE+0x900 | UART1 ステータス/コントロールレジスタ
.equ UBAUD1, REGBASE+0x902 | UART1 ボーコントロールレジスタ
.equ URX1, REGBASE+0x904 | UART1 受信レジスタ
.equ UTX1, REGBASE+0x906 | UART1 送信レジスタ
***************
** LED
***************
.equ LED7, IOBASE+0x000002f | ボード搭載の LED 用レジスタ
.equ LED6, IOBASE+0x000002d | 使用法については付録 A.4.3.1
.equ LED5, IOBASE+0x000002b
.equ LED4, IOBASE+0x0000029
.equ LED3, IOBASE+0x000003f
.equ LED2, IOBASE+0x000003d
.equ LED1, IOBASE+0x000003b
.equ LED0, IOBASE+0x0000039
**************************************************************
** スタック領域の確保
***************************************************************
.section .bss
.even
SYS_STK:.ds.b 0x4000 | システムスタック領域
.even
SYS_STK_TOP: | システムスタック領域の最後尾

/* step7で追記 */
.even
task_p:.ds.l 1

***************************************************************
** 初期化
** 内部デバイスレジスタには特定の値が設定されている．
** その理由を知るには，付録 B にある各レジスタの仕様を参照すること．
***************************************************************
	.extern start
	.global monitor_begin
	.section .text
	.even
monitor_begin:
boot: * スーパーバイザ & 各種設定を行っている最中の割込禁止
	move.w #0x2700,%SR/*走行レベルを7にして割込みを禁止　冨田*/
	lea.l SYS_STK_TOP, %SP | Set SSP/*スタック領域の確保*/
****************
** 割り込みコントローラの初期化
****************
	move.b #0x40, IVR | ユーザ割り込みベクタ番号を| 0x40+level に設定．/*藤が以下まで作成*/
*	move.l #0xff3ffb,IMR | 全割り込みマスク /*Step7以降可能となったためコメントアウト*/
	move.l #0xff3ff9, IMR /* Timer1割込み、UART割込み許可 */
****************
** 送受信 (UART1) 関係の初期化
****************
	move.w #0x0000, USTCNT1 | リセット
	move.w #0xe10c, USTCNT1 | 送受信可能, パリティなし, 1 stop, 8 bit,| 送受信割り込み可
	move.l #uart1_interrupt, 0x110 /* 送受信割り込みをレベル4に設定 */
	move.l #timer_interrupt, 0x118 /* タイマ割り込みをレベル6に設定 */
	move.l #trap_handler, 0x080 /*trap命令*/
	move.w #0x0038, UBAUD1 | baud rate = 230400 bps
****************
**キューの初期化
****************
	jsr	Q_Init /* キューの初期化 */
****************
** タイマ関係の初期化 (割り込みレベルは 6 に固定されている)
*****************
*	move.w #0x0004, TCTL1 | restart, 割り込み不可,| システムクロックの 1/16 を単位として計時，| タイマ使用停止 /*Step7以降可能となったためコメントアウト*/
	move.w #0x2000,%SR /*走行レベルを0にして割り込み許可*/
	/*bra MAIN藤がここまで制作*/
	jmp start
***************
** システムコール番号
***************
	.equ SYSCALL_NUM_GETSTRING, 1/*冨田が制作*/
	.equ SYSCALL_NUM_PUTSTRING, 2
	.equ SYSCALL_NUM_RESET_TIMER, 3
	.equ SYSCALL_NUM_SET_TIMER, 4
	.equ SYSCALL_NUM_SKIPMP, 5
****************************************************************
*** プログラム領域
****************************************************************
.section .text
.even
MAIN:
** 走行モードとレベルの設定 (「ユーザモード」への移行処理)/*以下藤が制作*/
	move.w #0x0000, %SR | USER MODE, LEVEL 0
	lea.l USR_STK_TOP,%SP | user stack の設定
** システムコールによる RESET_TIMER の起動
	move.l #SYSCALL_NUM_RESET_TIMER,%D0
	trap #0
** システムコールによる SET_TIMER の起動
	move.l #SYSCALL_NUM_SET_TIMER, %D0
	move.w #50000, %D1
	move.l #TT, %D2
	trap #0/*ここまで藤が制作*/
******************************
* sys_GETSTRING, sys_PUTSTRING のテスト
* ターミナルの入力をエコーバックする
******************************
LOOP:
	move.l #SYSCALL_NUM_GETSTRING, %D0
	move.l #0, %D1 | ch = 0
	move.l #BUF, %D2 | p = #BUF
	move.l #256, %D3 | size = 256
	trap #0
	move.l %D0, %D3 | size = %D0 (length of given string)
	move.l #SYSCALL_NUM_PUTSTRING, %D0
	move.l #0, %D1 | ch = 0
	move.l #BUF,%D2 | p = #BUF
	trap #0
	bra LOOP
******************************
* タイマのテスト
* ’******’ を表示し改行する．
* ５回実行すると，RESET_TIMER をする．
******************************
TT:
	movem.l %D0-%D7/%A0-%A6,-(%SP)
	cmpi.w #5,TTC | TTC カウンタで 5 回実行したかどうか数える
	beq TTKILL | 5 回実行したら，タイマを止める
	move.l #SYSCALL_NUM_PUTSTRING,%D0
	move.l #0, %D1 | ch = 0
	move.l #TMSG, %D2 | p = #TMSG
	move.l #8, %D3 | size = 8
	trap #0
	addi.w #1,TTC | TTC カウンタを1 つ増やして
	bra TTEND | そのまま戻る
TTKILL:
	move.l #SYSCALL_NUM_RESET_TIMER,%D0
	trap #0
TTEND:
	movem.l (%SP)+,%D0-%D7/%A0-%A6
	rts

******************************************************
trap_handler:/*藤が制作　トラップ命令がきたら*/
	movem.l %D1-%D7/%A0-%A6,-(%SP)/*レジスタ退避：d0レジスタは使用するので対比しない（藤）*/
	cmp #1, %d0 /* SYSCALL_NUM_GETSTRINGが呼び出されたとき、d0<=1（中嶋） */
	bne G1
	jsr GETSTRING /* d0が1ならばGETSTRINGを呼び出す(藤) */
	bra trap_end /* trap命令の終了(中嶋)*/
G1:	
	cmp #2, %d0 /* SYSCALL_NUM_PUTSTRINGが呼び出されたとき、d0<=2（中嶋） */
	bne G2
	jsr PUTSTRING /* d0が2ならばPUTSTRINGを呼び出す(藤) */
	bra trap_end /* trap命令の終了(中嶋)*/
G2:	
	cmp #3, %d0 /* SYSCALL_RESET_TIMERが呼び出されたとき、d0<=3（中嶋） */
	bne G3
	jsr RESET_TIMER /* d0が3ならばPUTSTRINGを呼び出す(藤) */
	bra trap_end /* trap命令の終了(中嶋)*/
G3:	
	cmp #4, %d0 /* SYSCALL_SET_TIMERが呼び出されたとき、d0<=4（中嶋） */
	bne G4 /* d0が4ならばPUTSTRINGを呼び出す(藤) */
	jsr SET_TIMER /* trap命令の終了(中嶋)*/
	bra trap_end
G4:	
	cmp #5, %d0 /* SYSCALL_SET_TIMERが呼び出されたとき、d0<=4（中嶋） */
	bne trap_end /* d0が4ならばPUTSTRINGを呼び出す(藤) */
	/*jsr skipmt /* trap命令の終了(中嶋)*/
trap_end:	
	movem.l (%SP)+,%D1-%D7/%A0-%A6 /* レジスタ復帰（藤） */
	rte

**********************************************
uart1_interrupt: /*冨田が制作　割り込み命令が来たら先に受信かチェック */
	movem.l %d0-%d7/%a0-%a6, -(%sp) /* レジスタ退避（冨田）*/
	move.w URX1, %d3 /*URX1をd3に格納（冨田）*/
	move.b %d3, %d2
	btst #13,%d3 /* 以下2行でURX1の13ビット目をチェック（中嶋）*/
	beq UART_EXIT1/*13ビット目が0だったらジャンプ　０なら受信キューにデータがない*/
	move.l #0, %d1
	jsr INTERGET /*INTERGETへ（中嶋）*/

UART_EXIT1:
	move.w UTX1, %d0 /* UTX1をd0に格納（冨田）*/
	btst #15, %d0 /* 以下2行でUTX1の15ビット目をチェック（中嶋）*/
	beq UART_EXIT2/*15ビットめが0ならジャンプ　0は送信キューが空じゃない*/
	move.l #0, %d1
	jsr INTERPUT /* INTERPUTへ（中嶋）*/

UART_EXIT2:
	movem.l (%sp)+,%d0-%d7/%a0-%a6 /* レジスタ復帰（冨田）*/
	rte

**********************************************
timer_interrupt:/*冨田が制作　タイマ割り込みが発生したら*/
	movem.l %d0-%d7/%a0-%a6, -(%sp) /* レジスタ退避（冨田） */
	move.w TSTAT1,%d0/*タイマの値に達しているかどうかをフラグを使って確認（冨田）*/
	btst #0,%d0 /* 以下2行でTSTAT1の0ビット目をチェック（中嶋） */
	beq TIMER_EXIT
	move.w #0,TSTAT1 /* TSTAT1を0に（中嶋） */
	jsr CALL_RP

TIMER_EXIT:
	movem.l (%sp)+,%d0-%d7/%a0-%a6 /* レジスタ復帰（冨田） */
	rte

*****************************************
** タイマ関連のサブルーチン 中嶋が作成
*****************************************
RESET_TIMER:
	/* TCTL1はタイマ1コントロールレジスタ、プリスケーラへの入力クロック設定などを行う (藤・冨田) */
	move.w #0x0004, TCTL1 /* 比較割り込みとタイマ禁止、CLKSOURSEは010(SYSCLK/16設定) (中嶋) */
	rts

SET_TIMER:
	/* %d1を周期t, %d2を起動するルーチンの先頭アドレスとする (藤・冨田) */
	/* TPRER1はタイマ1プリスケーラレジスタ、出力周波数（割る数）を設定 (藤・冨田) */
	/* TCMP1はタイマ1コンペアレジスタ、コンペアイベントを発生させる周期を設定 (藤・冨田) */
	movem.l %d1-%d2, -(%sp) /* レジスタ退避 (中嶋) */
	move.l %d2, task_p /* 大域変数にアドレスを代入 (中嶋) */
	move.w #206, TPRER1 /* 206は計算で求めた (中嶋) */
	move.w %d1, TCMP1 /* 周期を設定 (中嶋) */
	move.w #0x0015, TCTL1 /* 比較割り込みとタイマ許可、CLKSOURSEは010(SYSCLK/16設定) (中嶋) */
	movem.l (%sp)+, %d1-%d2 /* レジスタ復帰 (中嶋) */
	rts

CALL_RP:
	/* タイマ割り込み時に処理すべきルーチンの呼び出し (藤・冨田) */
	movem.l	%a0, -(%sp)
	movea.l task_p, %a0
	jsr (%a0) /* 大域変数 task_p の指すアドレスへジャンプする (中嶋) */
	movem.l	(%sp)+, %a0
	rts

************************************************
** PUTSTRING（作成者：佐倉）	
** 概要：指定したアドレスから始まるデータを
**       送信キューに格納し、送信割り込みを開始する
** 入力：%d1.l=チャネルch, %d2.l=読み込み先の先頭アドレスp, %d3.l=送信するデータ数size
** 出力：%d0.l=実際に送信したデータ数sz
************************************************
PUTSTRING:
	movem.l	%d1-%d5/%a0, -(%sp)	/* レジスタを退避 (佐倉) */

	cmpi.l	#0x00000000, %d1	/* chが0でなければ何もせず復帰 (佐倉) */
	bne	PUTSTRING_END

	move.l	#0x00000000, %d4	/* 送信したデータ数を%d4に設定 (佐倉) */
	movea.l	%d2, %a0		/* データ読込先の先頭アドレスを%a0に設定 (佐倉) */

	cmpi.l	#0x00000000, %d3	/* 送信する0ならばマスク処理へ (佐倉) */
	beq	PUTSTRING_END_SKIP_UNMASK
	
PUTSTRING_LOOP:
	cmp.l	%d3, %d4		/* 送信したデータ数が指定したサイズと等しければマスク処理へ (佐倉) */
	beq	PUTSTRING_UNMASK

	move.l	#0x00000001, %d0	/* 送信キューへの書き込み (佐倉) */
	move.b	(%a0), %d1		/* 成功：%d0.l=1, 失敗：%d0.l=0 (島添) */
	jsr	INQ

	cmpi.l	#0x00000000, %d0	/* 書き込み失敗(キューが満杯)ならマスク処理へ (佐倉) */
	beq	PUTSTRING_UNMASK
	addq	#1, %d4			/* 送信したデータ数を1加算 (佐倉) */
	addq	#1, %a0			/* 読み込み先アドレスを1加算 (佐倉) */
	bra	PUTSTRING_LOOP		/* ループ先頭へ (佐倉) */
PUTSTRING_UNMASK:
	move.w	USTCNT1, %d5		/* USTCNT1を操作し送信割り込み許可 (佐倉) */
	ori.w	#0x0004, %d5		/* USTCNT1の第2bit(TXEE)をセットし割り込みを許可 (島添) */
	move.w	%d5, USTCNT1
PUTSTRING_END_SKIP_UNMASK:
	move.l	%d4, %d0		/* 送信したデータ数を%d0に転送 (佐倉) */
PUTSTRING_END:	
	movem.l	(%sp)+, %d1-%d5/%a0	/* レジスタを復帰 (佐倉) */
	rts

************************************************
** INTERPUT（作成者：佐倉）
** 概要：送信キューからデータを1つ取り出して出力する    
** 入力：%d1.l=チャネルch
** 出力：無し
************************************************
INTERPUT:
	move.w	%SR, -(%sp)		/* 現走行レベルの退避 (佐倉) */
	move.w	#0x2700, %SR		/* 走行レベルを7に設定 (佐倉) */
	movem.l %d0-%d2, -(%sp)		/* レジスタの退避 (佐倉) */

	cmpi.l	#0x00000000, %d1	/* chが0でないなら何もせず復帰 (佐倉) */
	bne	INTERPUT_END

	move.l	#0x00000001, %d0	/* 送信キューからデータを取り出す (佐倉) */
	jsr	OUTQ			/* 取り出されたデータ=%d1.l (島添) */
					/* 成功：%d0.l=1, 失敗：%d0.l=0 (島添) */
	
	cmpi.l	#0x00000000, %d0	/* 取り出し失敗ならマスク処理して復帰 (佐倉) */
	bne	PUT
	move.w	USTCNT1, %d2		/* USTCNT1を操作し送信割り込みをマスク (佐倉) */
	andi.w	#0xFFFB, %d2		/* USTCNT1の第2bit(TXEE)をクリアし割り込みをマスク (島添) */
	move.w	%d2, USTCNT1
	bra	INTERPUT_END
PUT:
	and.w	#0x00FF, %d1		/* %d1の上位バイトをクリア (島添) */
	ori.w	#0x0800, %d1		/* ヘッダ付与 (島添) */
	move.w	%d1, UTX1		/* 送信 (佐倉) */
INTERPUT_END:
	movem.l	(%sp)+, %d0-%d2		/* レジスタの復帰 (佐倉) */
	move.w	(%sp)+, %SR		/* 走行レベルの復帰 (佐倉) */
	rts

************************************************
** INTERGET
************************************************
INTERGET: /* 入力d1:チャネルch　d2:受信データdata（島添）**/
	movem.l	%d0-%d2,-(%sp)	/* レジスタ退避（島添）**/
	
	cmpi	#0,%d1	/* チャネルが0であるか判定（島添）**/
	bne	INTERGET_Finish	/* チャネル0以外の場合終了処理（島添）**/
	move.l	#0,%d0	/* INQで使用するキューの選択（佐倉）**/
	move.b	%d2,%d1	/* INQへの入力（佐倉）**/
	jsr	INQ	/* INQ呼び出し（島添）**/

INTERGET_Finish:
	movem.l	(%sp)+,%d0-%d2/* レジスタ回復（島添）**/
	rts

************************************************
** GETSTRING
************************************************
GETSTRING: /* 入力d1:チャネルch　d2：データ書き込みの先の先頭アドレスp　d3：取り出すデータサイズsize（島添）*/
	/* 出力d0：実際に取り出したデータサイズsz（島添）*/
	movem.l	%d1-%d4/%a0,-(%sp)	/* レジスタ退避（島添）**/
	cmpi.l	#0,%d1	/* チャネルが0であるか判定（島添）**/
	bne	GETSTRING_Finish	/* チャネル0以外でGETSTRING終了処理へ（佐倉）**/
	move.l	%d2,%a0	/* i:データ書き込み先の先頭アドレス（佐倉）**/
	move	#0,%d4	/* sz：実際に取り出したデータサイズ（佐倉）**/
	
GETSTRING1:	
	cmp	%d3,%d4	/* 実際に取り出したデータサイズが入力d3:取り出すデータサイズに一致するか判定（島添）**/
	beq	GETSTRING2	/* 一致した場合d0にデータサイズを書き込んで終了処理（島添）**/

	move.l	#0x00000000, %d0	/* d0の初期化（島添）**/
	jsr	OUTQ	/* OUTQを呼び出し、バッファに入っているデータの取り出し（島添）**/
	/* OUTQはd0に対して失敗時0、成功時1を出力する（佐倉）**/
	cmpi	#0,%d0	/* OUTQが失敗なら出力値を書き込み終了処理へ（島添）**/
	beq	GETSTRING2
	move.b	%d1,(%a0)+	/* p番地にコピー i++（島添）**/
	add	#1,%d4	/* sz++（島添）**/
	bra	GETSTRING1	/* GETSTRING1をループ（島添）**/
	
GETSTRING2:
	move	%d4,%d0	/* 実際に取り出したデータサイズを出力としてd0に書き込む（島添）**/
	
GETSTRING_Finish:
	movem.l	(%sp)+,%d1-%d4/%a0	/* レジスタ回復（島添）**/
	rts
	
*************************************************
** キュー
*************************************************
Q_Init: /* 初期化（島添）*/
	movem.l	%a0-%a5, -(%sp)	/* レジスタ退避（島添）*/

	lea.l	BF_START, %a0	/* キュー作成のために確保した領域の先頭アドレスを取得（島添）*/
	move.l	%a0, top	/* キュー0の先頭アドレスの書き込み（島添）*/
	move.l	%a0, out	/* キュー0のOUTQにて次にアクセスするアドレスを書き込み（島添）*/
	move.l	%a0, in	/* キュー0に対するINQにて次にアクセスするアドレスを書き込み（島添）*/
	add	#255, %a0	/* キュー0の最後尾のアドレスを計算（島添）*/
	move.l	%a0, bottom	/* キュー0の最後尾のアドレスを書き込み（島添）*/
	move.l	#0x00, s	/* キュー0の保存されているデータ数を初期化（島添）*/
	
	lea.l	top, %a1	/* 以下はキュー0と同じようにキュー1の初期化を行うための処理（島添）*/
	lea.l	out, %a2
	lea.l	in, %a3
	lea.l	bottom, %a4
	lea.l	s, %a5

	addq	#1, %a0
	move.l	%a0, 4(%a1)	/* (top+4)でキュー1のtop (佐倉) */
	move.l	%a0, 4(%a2)	/* (out+4)でキュー1のout (佐倉) */
	move.l	%a0, 4(%a3)	/* (in+4)でキュー1のin (佐倉) */
	add	#255, %a0	
	move.l	%a0, 4(%a4)	/* (bottom+4)でキュー1のbottom (佐倉) */
	move.l	#0x00, 4(%a5)	/* (s+4)でキュー1のs (佐倉) */
	
	movem.l	(%sp)+, %a0-%a5	/* レジスタの回復 */
	rts


************************************************
** INQ（作成者：佐倉）
** 概要：指定したキューにデータを書き込む
** 入力：%d0.l=キュー番号no, %d1.b=書き込みデータ
** 出力：%d0.l=成功：1, 失敗：0
************************************************	
INQ:
	move.w	%SR, -(%sp)		/* 現走行レベルの退避 (佐倉) */
	ori.w	#0x0700, %SR		/* 走行レベルを7に設定 (佐倉) */
	movem.l	%d1-%d3/%a0-%a5, -(%sp)	/* レジスタの退避 (佐倉) */

	move.l	#4, %d3			/* オフセット%d3の生成 (佐倉) */
	mulu	%d0,%d3			/* 受信キュー：%d3=0, 送信キュー：%d3=4 (島添) */
	
	lea.l	s, %a0			/* サイズを比較し書き込み可能か判定 (佐倉) */
	move.l	(%a0, %d3), %d2		/* %d2に指定キューのサイズ(s+オフセット)を転送 (島添) */
	cmp	#256, %d2		/* サイズが256でなければ書き込み可能なので書き込み処理へ (島添) */
	bne	IN_STEP_1
	move.l	#0, %d0			/* 256ならば%d0.l=0として終了 (島添) */
	bra	INQ_END
	
IN_STEP_1:
	lea.l	in, %a1			/* データ書き込み先アドレスを%a1に (佐倉) */
	lea.l	bottom, %a4		/* キューの末尾アドレスを%a4に (佐倉) */
	lea.l	top, %a5		/* キューの先頭アドレスを%a5に (佐倉) */
	movea.l	(%a1, %d3), %a3     	/* 指定キューの書き込み先アドレス(in+オフセット)のアドレスを%a3に (佐倉) */
	move.b	%d1, (%a3)         	/* データの書き込み (佐倉) */

	addq.l	#1, (%a0, %d3)		/* (s+オフセット)の値をインクリメント (佐倉) */
	
	movea.l	(%a4, %d3), %a2    	/* 指定キューの末尾アドレス(bottom+オフセット)のアドレスを%a2に (佐倉) */
	cmpa.l	%a3, %a2           	/* データを書き込んだアドレスと末尾アドレスを比較 (佐倉) */
	bne	IN_INC            

	movea.l	(%a5, %d3), %a3    	/* 等しければ指定キューの先頭アドレス(top+オフセット)を%a3に転送しアドレス処理へ (島添) */
	bra	IN_STORE
	
IN_INC:
	addq.l	#1, %a3           	/* 等しくなければ書き込み先アドレスをインクリメントしアドレス処理へ (島添) */
	
IN_STORE:
	move.l	%a3, (%a1, %d3)  	/* 書き込み先アドレスを更新 (佐倉) */
	move.l	#1, %d0			/* 書き込み成功として戻り値を1に (佐倉) */
	
INQ_END:	
	movem.l	(%sp)+, %d1-%d3/%a0-%a5	/* レジスタの復帰 (佐倉) */
	move.w	(%sp)+, %SR		/* 走行レベルの復帰 (佐倉) */
	rts

**********************************************
OUTQ:
	move.w	%SR, -(%sp)	/* ステータスレジスタの退避（島添）*/
	ori.w	#0x0700, %SR	/* 走行レベルを7に（島添）*/
	
	movem.l	%d2-%d3/%a0-%a5, -(%sp)	/* レジスタの退避（島添）*/
	
	move.l	#4, %d3	/* 間接アクセスのための4倍の値（佐倉）*/
	mulu	%d0, %d3	/* 使用するキューとd3の乗算(オフセット)（佐倉）*/
	
	lea.l	s, %a0	/* s:保存されているデータ数を保持 先頭から4ビットはキュー0、その後ろ4ビットはキュー1（佐倉）*/
	move.l	(%a0, %d3), %d2	/* 今回扱うキューに保存されているデータ数をd2に書き込み（島添）*/
				/* (s+オフセット)で指定キューのs (佐倉) */
	cmp	#0, %d2		/* 保存されているデータが0であれば終了処理（島添）*/
	bne	OUT_STEP_1
	
	move.l	#0, %d0	/* 保存されているデータ数が0の場合失敗を出力して終了（島添）*/
	bra	OUTQ_END
	
OUT_STEP_1:
    	lea.l	out, %a1	/* データ読み取り先のアドレスを保存しているメモリアドレスの取得（島添）*/
	lea.l	bottom, %a4	/* それぞれのキューの末尾のアドレスを保存しているメモリアドレスの取得（島添）*/
	lea.l	top, %a5	/* それぞれのキューの先頭のアドレスを保存しているメモリアドレスの取得（島添）*/
	
	movea.l	(%a1, %d3), %a3	/* 今回扱うキューのデータ読み取り先のアドレスをa3に書き込み（島添）*/
				/* (out+オフセット)で指定キューのout (佐倉) */
	move.b	(%a3), %d1	/* d1に値の読み取り（島添）*/
	and.l   #0x000000FF, %d1/* d1の上位3ビットを0に（島添）*/

	subq.l	#1, (%a0, %d3)	/* sに保存している値を1減らす（島添）*/
	
	movea.l	(%a4, %d3), %a2	/* 今回扱っているキューの最後尾のアドレスを取得（島添）*/
				/* (bottom+オフセット)で指定キューのbottom (佐倉) */
	cmpa.l	%a3, %a2	/* 先程読み取った値が保存されていたのがキューの最後尾か判定（島添）*/
	bne	OUT_INC	/* 最後尾でなければoutの値を1加算（島添）*/
	
	movea.l	(%a5, %d3), %a3	/* 最後尾であればoutを先頭に戻す（島添）*/
	bra	OUT_STORE
	
OUT_INC:
	addq.l	#1, %a3	/* outのアドレスに1加算（島添）*/
	
OUT_STORE:
	move.l	%a3, (%a1, %d3)	/* outに次回読み取りを行うアドレスを書き込み（島添）*/
	move.l	#1, %d0	/* OUTQ成功を出力（島添）*/
	
OUTQ_END:
	movem.l	(%sp)+, %d2-%d3/%a0-%a5	/* レジスタの回復（島添）**/
	move.w	(%sp)+, %SR	/* ステータスレジスタの回復（島添）**/
	rts
	
****************************************************************
*** 初期値のあるデータ領域
****************************************************************
.section .data
TMSG:
.ascii "******\r\n" | \r: 行頭へ(キャリッジリターン)
.even | \n: 次の行へ(ラインフィード)
TTC:
.dc.w 0
.even
	
****************************************************************
*** 初期値の無いデータ領域
****************************************************************
.section .bss
	
** キュー関係の領域	
BF_START:	.ds.b	512 | バッファ領域
top:		.ds.l	2   | 先頭アドレス用領域
out:		.ds.l	2   | 読み出し先アドレス格納用領域
in:		.ds.l	2   | 書き込み先アドレス格納用領域
bottom:		.ds.l	2   | 末尾アドレス格納用領域
s:		.ds.l	2   | 格納されているデータ数格納用領域

BUF:
.ds.b 256 | BUF[256] | 作業用バッファ
.even
	
USR_STK:
.ds.b 0x4000 | ユーザスタック領域
.even
USR_STK_TOP: | ユーザスタック領域の最後尾

.end
